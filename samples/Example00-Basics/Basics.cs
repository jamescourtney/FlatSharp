/*
 * Copyright 2020 James Courtney
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace Samples.Basics;

/// <summary>
/// This sample shows the basic usage of FlatSharp using the Monster example. These types
/// are defined in Basics.fbs and are generated by the FlatSharp compiler.
/// </summary>
public class Basics : IFlatSharpSample
{
    public void Run()
    {
        // Make a monster! The definition for moster is defined in Basics.fbs, which sits alongside this file.
        Monster monster = new Monster
        {
            Color = Color.Green,
            Equipped = new Equipped(new Weapon { Damage = 100, Name = "Master sword" }),
            Friendly = true,
            HP = 932,
            Inventory = new byte[] { 1, 2, 3, 4, 5, },
            Mana = 32,
            Name = "Link",
            Pos = new Vec3 { X = 1.1f, Y = 3.2f, Z = 2.6f },
            Weapons = new List<Weapon> { new Weapon { Damage = 6, Name = "Hook shot" }, new Weapon { Name = "Bow and Arrow", Damage = 37 } },
            Path = new Vec3[]
            {
                new Vec3 { X = 1f, Y = 2f, Z = 3f },
                new Vec3 { X = 4f, Y = 5f, Z = 6f },
                new Vec3 { X = 7f, Y = 8f, Z = 9f }
            }
        };

        // Ask the serializer what the max size necessary to write this particular monster. Different
        // monsters will need different amounts of space.
        int maxSize = Monster.Serializer.GetMaxSize(monster);

        byte[] buffer = new byte[maxSize];
        int bytesWritten = Monster.Serializer.Write(buffer, monster);

        // Looks the same to me!
        Monster parsedMonster = Monster.Serializer.Parse(buffer.AsSpan().Slice(0, bytesWritten).ToArray());

        Func<Monster, (string, object?)>[] getters = new Func<Monster, (string, object?)>[]
        {
            m => (nameof(Monster.Color), m.Color),
            m => (nameof(Monster.Name), m.Name),
            m => (nameof(Monster.Path), string.Join(",", m.Path?.Select(x => $"({x.X},{x.Y},{x.Z})") ?? Array.Empty<string>())),
            m => (nameof(Monster.Weapons), string.Join(",", m.Weapons?.Select(x => x.Name) ?? Array.Empty<string>()))
        };

        foreach (var getter in getters)
        {
            (string name, object? original) = getter(monster);
            (_, object? parsed) = getter(parsedMonster);

            Console.WriteLine($"{name}: Original='{original}' Parsed='{parsed}'");
        }
    }
}