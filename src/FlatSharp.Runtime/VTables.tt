/*
 * Copyright 2021 James Courtney
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

using System.Buffers.Binary;
using System.Runtime.InteropServices;

namespace FlatSharp;

<# 
    int numVtables = 8;
    for (int i = 1; i <= numVtables; ++i)
    {
        int maxIndex = i - 1;
#>

/// <summary>
/// Represents a vtable for a table with <#= i #> fields.
/// </summary>
[EditorBrowsable(EditorBrowsableState.Never)]
[StructLayout(LayoutKind.Explicit, Size = <#= 2 * i #>)]
[ExcludeFromCodeCoverage]
public struct VTable<#= i #> : IVTable
{
    <#
       for (int j = 0; j < i; ++j)
       {
    #>
    
    [FieldOffset(<#= 2 * j #>)]
    private ushort offset<#= j #>;

    <#
       }
    #>

    public static void Create<TInputBuffer>(TInputBuffer inputBuffer, int offset, out VTable<#= i #> item)
        where TInputBuffer : IInputBuffer
    {
        inputBuffer.InitializeVTable(offset, out int vtableOffset, out int maxVtableIndex, out ushort vtableLength);
        ReadOnlySpan<byte> vtable = inputBuffer.AsReadOnlySpan().Slice(vtableOffset, vtableLength);

        
        if (BitConverter.IsLittleEndian && (uint)vtable.Length >= (nuint)<#= 6 + (2 * maxIndex) #>)
        {
            item = MemoryMarshal.Cast<byte, VTable<#= i #>>(vtable.Slice(4, <#= 2 * i #>))[0];
        }
        else
        {
            item = new VTable<#= i #>();
            switch (maxVtableIndex)
            {
<#
    for (int j = 0; j < i; ++j)
    {
#>
                case <#= j #>:
                {
                    vtable = vtable.Slice(4, <#= 2 * (j + 1)#>);
<#
        for (int k = 0; k <= j; ++k)
        {
#>
                    item.offset<#= k #> = BinaryPrimitives.ReadUInt16LittleEndian(vtable.Slice(<#= 2 * k #>, 2));
<#
        }
#>
                }
                break;

<#
    }
#>
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int OffsetOf<TInputBuffer>(TInputBuffer buffer, int index)
        where TInputBuffer : IInputBuffer
    {
        switch (index)
        {
<#
    for (int j = 0; j < i; ++j)
    {
#>
            case <#= j #>: return this.offset<#= j #>;
<#
    }
#>
            default: return 0;
        }
    }
}

<#
    }
#>
