/*
 * Copyright 2020 James Courtney
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System.Threading;

namespace FlatSharp.Internal;

/// <summary>
/// An implementation of IIndexedVector for use after deserializing an object. This class is not intended to be used
/// directly -- only from code generated by FlatSharp.
/// </summary>
public class FlatBufferIndexedVector<TKey, TValue> 
    : IIndexedVector<TKey, TValue>

    where TValue : class, ISortableTable<TKey>
    where TKey : notnull
{
    private IList<TValue> list;

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
    private FlatBufferIndexedVector()
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
    {
    }

    public static FlatBufferIndexedVector<TKey, TValue> GetOrCreate(IList<TValue> list)
    {
        if (!ObjectPool.TryGet<FlatBufferIndexedVector<TKey, TValue>>(out var item))
        {
            item = new();
        }

        item.list = list;
        return item;
    }

    public TValue this[TKey key]
    {
        get
        {
            if (!this.TryGetValue(key, out TValue? value))
            {
                FSThrow.KeyNotFound();
            }

            return value;
        }
    }

    /// <summary>
    /// Always readonly.
    /// </summary>
    public bool IsReadOnly => true;

    /// <summary>
    /// Gets the count of items.
    /// </summary>
    public int Count => this.list.Count;

    /// <summary>
    /// No-op. We are already immutable.
    /// </summary>
    public void Freeze()
    {
    }

    public void AddOrReplace(TValue value)
    {
        FSThrow.NotMutable();
    }

    public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
    {
        foreach (var value in this.list)
        {
            yield return new KeyValuePair<TKey, TValue>(IndexedVector<TKey, TValue>.GetKey(value), value);
        }
    }

    IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();

    public bool Add(TValue value)
    {
        return FSThrow.NotMutable<bool>();
    }

    public bool TryGetValue(TKey key, [NotNullWhen(true)] out TValue? value)
    {
        value = SortedVectorHelpers.BinarySearchByFlatBufferKey(this.list, key);
        return value is not null;
    }

    public bool ContainsKey(TKey key)
    {
        return this.TryGetValue(key, out _);
    }

    public void Clear()
    {
        FSThrow.NotMutable();
    }

    public bool Remove(TKey key)
    {
        return FSThrow.NotMutable<bool>();
    }

    public void ReturnToPool(bool force = false)
    {
        if (FlatBufferDeserializationOption.Lazy.ShouldReturnToPool(force))
        {
            var vec = Interlocked.Exchange(ref this.list!, null);
            if (vec is not null)
            {
                (vec as IPoolableObject)?.ReturnToPool(true);
                ObjectPool.Return(this);
            }
        }
    }
}
