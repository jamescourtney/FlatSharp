/*
 * Copyright 2020 James Courtney
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

<#
    (
        string casedName, string commonName, string typeName, string literalSpecifier, string[] fbsAliases, string inlineWriteMethod)[] types =
            {
                ("Bool", "Bool", "bool", "", new[] { "bool" }, "SerializationHelpers.WriteBool"),
                ("UInt8", "Byte", "byte", "", new[] { "ubyte", "uint8" }, "SerializationHelpers.WriteUInt8"),
                ("Int8", "SByte", "sbyte", "", new[] { "byte", "int8" }, "SerializationHelpers.WriteInt8"),
                ("UInt16", "UShort", "ushort", "", new[] { "ushort", "uint16" }, "global::System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian"),
                ("Int16", "Short", "short", "", new[] { "short", "int16" }, "global::System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian"),
                ("Int32", "Int", "int", "", new[] { "int", "int32" }, "global::System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian"),
                ("UInt32", "UInt", "uint", "u", new[] { "uint", "uint32" }, "global::System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian"),
                ("Int64", "Long", "long", "L", new[] { "long", "int64" }, "global::System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian"),
                ("UInt64", "ULong", "ulong", "ul", new[] { "ulong", "uint64" }, "global::System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian"),
                ("Float32", "Float", "float", "f", new[] { "float", "float32" }, "SerializationHelpers.WriteFloat32"),
                ("Float64", "Double", "double", "d", new[] { "double", "float64" }, "SerializationHelpers.WriteFloat64"),
            };
#>

namespace FlatSharp.TypeModel;

<#
    foreach (var pair in types)
    {
        var casedName = pair.casedName;
        var typeName = pair.typeName;
        var commonName = pair.commonName;
        var className = $"{commonName}TypeModel";
        var writeMethod = pair.inlineWriteMethod;
#>
    
/// <summary>
/// Type Model for <see cref="<#= typeName #>"/>.
/// </summary>
[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
public partial class <#= className #> : ScalarTypeModel
{
    public <#= className #>(TypeModelContainer container) : base(container, typeof(<#=typeName#>), sizeof(<#=typeName#>)) 
    {
    }

    public override bool TryGetSpanComparerType([NotNullWhen(true)] out Type? comparerType)
    {
        comparerType = typeof(<#= commonName #>SpanComparer);
        return true;
    }

    protected override string InputBufferReadMethodName => "Read<#= commonName #>";

    protected override string WriteMethodName => "<#= writeMethod #>";

    protected override string TypeNameAlias => "<#=typeName#>";
    
    public override string GetDeserializedTypeName(FlatBufferDeserializationOption option, string inputBufferTypeName)
    {
        return "<#=typeName#>";
    }
}

<# } #>

public class ScalarTypeModelProvider : ITypeModelProvider
{
    public bool TryCreateTypeModel(
        TypeModelContainer container, 
        Type type, 
        [NotNullWhen(true)] out ITypeModel? typeModel)
    {
        typeModel = null;
    <#
        foreach (var pair in types)
        {
            var commonName = pair.commonName;
            var typeName = pair.typeName;
            var className = $"{commonName}TypeModel";
    #>

        if (type == typeof(<#= typeName #>))
        {
            typeModel = new <#= className #>(container); 
            return true;
        }

    <# } #>

        return false;
    }
}
